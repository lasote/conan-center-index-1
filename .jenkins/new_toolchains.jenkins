import org.yaml.snakeyaml.Yaml

properties([
    parameters([
        string(name: 'recipes', defaultValue: '', description: 'recipes, sepparated by commas that you want to regenerate. e.g. "zlib,openssl,cgal"')
    ]),
]) 

List<String> recipesToBuild = params.recipes.tokenize(',')

recipesToBuild = recipesToBuild.collect { it.trim() }

RAISE_HOOKS = true
ART_URL = 'https://conanv2beta.jfrog.io/artifactory/api/conan/conan'

// If you want the ci to run against
// a branch in a fork configure these variables

CONAN_BRANCH = ''
CONAN_FORK = ''
CONAN_FORK_VERSION = '' // 1.X if it's from Conan 1.X otherwise 2.0

void cancelPrevious() {
    stage("Cancelling previous") {
        def buildNumber = env.BUILD_NUMBER as int
        if (buildNumber > 1) milestone(buildNumber - 1)
        milestone(buildNumber)
    }
}

def isMaster() {
    String masterBranch = 'master'
    return env.BRANCH_NAME == masterBranch
}

def shouldUpload(branchName) {
    boolean isLatestAlpha  = branchName == "latest Conan 2.0-alpha"
    boolean developConan1  = branchName == "develop Conan 1.X"
    return isMaster() && (isLatestAlpha || developConan1)
}

String pipConanBranchInstall(String branch, String fork='conan-io') {
    return "-e git+https://github.com/${fork}/conan.git@${branch}#egg=conan"
}

List<Map> getBranchesInstalls() {
    def branches = [['name': 'latest Conan 2.0-alpha', 'branchInstall': 'conan --pre']]
    branches.add(0, ['name': 'develop Conan 1.X', 'branchInstall': pipConanBranchInstall('develop')])
    if (!isMaster()) {
        //branches.add(0, ['name': 'latest Conan 1.X', 'branchInstall': 'conan'])
        branches.add(0, ['name': 'develop Conan 2.0', 'branchInstall': pipConanBranchInstall('develop2')])
        if (CONAN_BRANCH != '' && CONAN_FORK != '') {
            branches.add(0, ['name': "${CONAN_FORK} - ${CONAN_BRANCH}(${CONAN_FORK_VERSION})", 'branchInstall': pipConanBranchInstall(CONAN_BRANCH, CONAN_FORK)]);
        }
    }
    return branches
}

LINUX_CONTAINER = 'conanio/gcc9'
LINUX_PROFILE = """\
    [settings]
    arch=x86_64
    build_type=Release
    compiler=gcc
    compiler.cppstd=gnu14
    compiler.libcxx=libstdc++11
    compiler.version=9
    os=Linux
    """.stripIndent()

MACOS_PROFILE = """\
    [settings]
    arch=x86_64
    build_type=Release
    compiler=apple-clang
    compiler.cppstd=gnu11
    compiler.libcxx=libc++
    compiler.version=13
    os=Macos
    """.stripIndent()

WINDOWS_PROFILE_v1 = """\
    [settings]
    os=Windows
    arch=x86_64
    compiler=Visual Studio
    compiler.runtime=MD
    compiler.version=15
    build_type=Release
    """.stripIndent()

WINDOWS_PROFILE_v2 = """\
    [settings]
    arch=x86_64
    build_type=Release
    compiler=msvc
    compiler.cppstd=14
    compiler.runtime=dynamic
    compiler.runtime_type=Release
    compiler.version=191
    os=Windows
    """.stripIndent()

def getWindowsProfile(branchName) {
    if (branchName.contains('1.X')) {
        return WINDOWS_PROFILE_v1
    }
    else {
        return WINDOWS_PROFILE_v2
    }
}

@NonCPS
static removeDuplicates(List list) {
    list.unique(true, { lhs, rhs -> lhs <=> rhs })
}

def envInside(Map ctxt, Closure closure) {
    String venvDirectory = isUnix() ? "${pwd()}/conanenv" : "${pwd()}\\conanenv"
    String binPath = isUnix() ? "$venvDirectory/bin/" : "$venvDirectory\\Scripts\\"
    String conanHome = isUnix() ? "${pwd()}/.conan" : "${pwd()}\\.conan"
    String hookErrorLevel = RAISE_HOOKS ? '40' : '50'
    withEnv(["PATH+EXTRA=${binPath}", "CONAN_HOME=${conanHome}", "CONAN_USER_HOME=${conanHome}", "CONAN_USER_HOME_SHORT=${conanHome}", "CONAN_HOOK_ERROR_LEVEL=${hookErrorLevel}", "CONAN_REVISIONS_ENABLED=1"]) {
        // This doesn't work if running docker.inside (https://issues.jenkins.io/browse/JENKINS-49076)
        closure()
    }
}

def envCreate(Map ctxt) {
    String venvDirectory = isUnix() ? "${pwd()}/conanenv" : "${pwd()}\\conanenv"
    String binPath = isUnix() ? "$venvDirectory/bin/" : "$venvDirectory\\Scripts\\"
    ctxt.shFunction("${ctxt.python_host} --version")
    if (ctxt.isInsideDocker) {
        // Alternate implementation because of https://issues.jenkins.io/browse/JENKINS-49076
        ctxt.shFunction("pip install ${ctxt.branch.branchInstall} --upgrade")
    }
    else {
        ctxt.shFunction("${ctxt.python_host} -m venv $venvDirectory")
        ctxt.shFunction("${binPath}python -m pip install -U pip")
        ctxt.shFunction("${binPath}python -m pip install ${ctxt.branch.branchInstall} --upgrade")
    }
}

def createReference(Map ctxt, List referencesToBuild) {
    try {
        checkout scm

        envCreate(ctxt)
        envInside(ctxt) {
            ctxt.shFunction('cmake --version')
            ctxt.shFunction('conan --version')
            ctxt.shFunction("conan remote remove conancenter")
            ctxt.shFunction("conan remote add conancenterv2 ${ART_URL}")
        }

        def referencesToUpload = []
        envInside(ctxt) {
            for (reference in referencesToBuild) {
                    // ctxt.shFunction("conan info ${reference.folder} --profile=default")
                    writeFile(file: 'pr_host', text: ctxt.profileHost)
                    def ret = -1
                    if (ctxt.branch.name.contains('1.X')) {
                        ret = ctxt.shReturnCode("conan create ${reference.folder} ${reference.name}/${reference.version}@ -pr:h=pr_host -pr:b=pr_host")
                    }
                    else {
                        ret = ctxt.shReturnCode("conan create ${reference.folder} --name ${reference.name} --version ${reference.version} -pr:h=pr_host -pr:b=pr_host")
                    }
                    if(ret !=0 && ret !=6){
                        error "The conan create failed!"
                    }
                    else if (ret !=6) {
                        referencesToUpload.add(reference)
                    }
            }
            if (ctxt.upload) {
                withCredentials([usernamePassword(credentialsId: 'artifactory-conanv2beta', usernameVariable: 'ARTIFACTORY_USER', passwordVariable: 'ARTIFACTORY_PASSWORD')]) {
                    if (ctxt.branch.name.contains('1.X')) {
                        if (ctxt.isWindows) {
                            ctxt.shFunction('conan user %ARTIFACTORY_USER% -r conancenterv2 -p %ARTIFACTORY_PASSWORD%')
                        }
                        else {
                            ctxt.shFunction('conan user $ARTIFACTORY_USER -r conancenterv2 -p $ARTIFACTORY_PASSWORD')
                        }
                    }
                    else {
                        if (ctxt.isWindows) {
                            ctxt.shFunction('conan remote login conancenterv2 %ARTIFACTORY_USER% -p %ARTIFACTORY_PASSWORD%')
                        }
                        else {
                            ctxt.shFunction('conan remote login conancenterv2 $ARTIFACTORY_USER -p $ARTIFACTORY_PASSWORD')
                        }
                    }
                }
                if (!referencesToUpload.isEmpty()) {
                    for (reference in referencesToUpload) {
                        if (ctxt.branch.name.contains('1.X')) {
                            ctxt.shFunction("conan upload ${reference.name}/${reference.version} -r conancenterv2 -c --all")
                        }
                        else {
                            ctxt.shFunction("conan upload ${reference.name}/${reference.version} -r conancenterv2 -c")
                        }
                    }
                }
            }
        }

    }
    finally {
        cleanWs(cleanWhenAborted: true, cleanWhenFailure: true, cleanWhenNotBuilt: true,
            cleanWhenSuccess: true, cleanWhenUnstable: true, disableDeferredWipeout: true, deleteDirs: true,
            notFailBuild: true)
    }
}

node('Linux') {
    cancelPrevious()

    def urc = scm.userRemoteConfigs
    urc[0].refspec = "${urc[0].refspec} +refs/heads/master:refs/remotes/origin/master"
    checkout([
        $class: 'GitSCM',
        branches: scm.branches,
        doGenerateSubmoduleConfigurations: scm.doGenerateSubmoduleConfigurations,
        extensions: scm.extensions,
        userRemoteConfigs: urc
    ])

    if (recipesToBuild.isEmpty()) {
        stage('Compute changes') {
            def output = null
            def previous_commit = null
            def current_commit = null

            if (isMaster()) {
                current_commit = sh(script: "git rev-parse HEAD", returnStdout: true).trim()
                previous_commit = sh(script: "git rev-parse HEAD^1", returnStdout: true).trim()
                output = sh(script: "git diff --name-only ${previous_commit}..${current_commit} --diff-filter=AMR", returnStdout: true)
            }
            else {
                output = sh(script: 'git diff --name-only origin/master --diff-filter=AMR', returnStdout: true)
            }
            for (line in output.split('\n')) {
                def matcher = (line =~ /^recipes\/([^\/]+)\//)
                if (matcher) {
                    recipesToBuild.add(matcher[0][1] as String)
                }
            }
        }
    }

    removeDuplicates(recipesToBuild)

    echo "Recipes to build:\n - ${ recipesToBuild.collect({ "$it" }).join('\n - ')}"

    if (!recipesToBuild.isEmpty()) {
        List toBuild = []
        stage('Parse config.yml to get versions') {
            for (recipe in recipesToBuild) {
                String content = readFile("recipes/${recipe}/config.yml")
                Yaml parser = new Yaml()
                Map data = parser.load(content)
                def versions = data.get('versions')
                for (int i = 0; i < versions.size(); i++) {
                    def version = versions.keySet()[i]
                    Map<String, String> props = versions[version]
                    toBuild.add([
                        folder: "recipes/${recipe}/${props.folder}/conanfile.py",
                        reference: "${recipe}/${version}",
                        name: "${recipe}",
                        version: "${version}"
                    ])
                }
            }
            echo "Versions to build:\n - ${ toBuild.collect({ "$it.reference: $it.folder" }).join('\n - ')}"
        }

        stage('Parallel on platforms') {
            def conanBranchesInstalls = getBranchesInstalls()
            parallel(
                linux: {
                    conanBranchesInstalls.each { branch ->
                        stage("${branch.name}") {
                            docker.image(LINUX_CONTAINER).inside {
                                createReference([python_host: 'python3',
                                                shFunction: { data -> sh(data) },
                                                shReturnCode: { data -> sh(script: data, returnStatus: true) },
                                                isWindows: false,
                                                isInsideDocker: true,
                                                profileHost: LINUX_PROFILE,
                                                branch: branch,
                                                upload: shouldUpload(branch.name)],
                                                toBuild)
                            }
                        }
                    }
                },
                macos: {
                    node('Macos') {
                        conanBranchesInstalls.each { branch ->
                            stage("${branch.name}") {
                                withEnv(['PATH+EXTRA=/usr/local/bin']) { // Required to find CMake
                                    createReference([python_host: 'python3',
                                                    shFunction: { data -> sh(data) },
                                                    shReturnCode: { data -> sh(script: data, returnStatus: true) },
                                                    isWindows: false,
                                                    isInsideDocker: false,
                                                    profileHost: MACOS_PROFILE,
                                                    branch: branch,
                                                    upload: shouldUpload(branch.name)],
                                                    toBuild)
                                }
                            }
                        }
                    }
                },
                windows: {
                    node('Windows') {
                        conanBranchesInstalls.each { branch ->
                            stage("${branch.name}") {
                                createReference([python_host: 'C:\\Python39\\python.exe',
                                                shFunction: { data -> bat(data) },
                                                shReturnCode: { data -> bat(script: data, returnStatus: true) },
                                                isWindows: true,
                                                isInsideDocker: false,
                                                profileHost: getWindowsProfile(branch.name),
                                                branch: branch,
                                                upload: shouldUpload(branch.name)],
                                                toBuild)
                            }
                        }
                    }
                }
            )
        }
    }
}
